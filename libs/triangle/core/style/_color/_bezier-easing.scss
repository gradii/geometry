$_NEWTON_ITERATIONS: 4;
$_NEWTON_MIN_SLOPE: 0.001;
$_SUBDIVISION_PRECISION: 0.0000001;
$_SUBDIVISION_MAX_ITERATIONS: 10;

$_kSplineTableSize: 11;
$_kSampleStepSize: 1.0 / ( $_kSplineTableSize - 1.0);

//$float32ArraySupported = typeof Float32Array === 'function';

@function _A ($aA1, $aA2) {
  @return 1.0 - 3.0 * $aA2 + 3.0 * $aA1;
}

@function _B ($aA1, $aA2) {
  @return 3.0 * $aA2 - 6.0 * $aA1;
}

@function _C ($aA1) {
  @return 3.0 * $aA1;
}

// Returns x(t) given t, x1, and x2, or y(t) given t, y1, and y2.
@function _calcBezier ($aT, $aA1, $aA2) {
  @return ((_A($aA1, $aA2) * $aT + _B($aA1, $aA2)) * $aT + _C($aA1)) * $aT;
}

// Returns dx/dt given t, x1, and x2, or dy/dt given t, y1, and y2.
@function _getSlope ($aT, $aA1, $aA2) {
  @return 3.0 * _A($aA1, $aA2) * $aT * $aT + 2.0 * _B($aA1, $aA2) * $aT + _C($aA1);
}

@function _binary-subdivide ($aX, $aA, $aB, $mX1, $mX2) {
  $currentT: false;
  $currentX: false;
  $i: 0;
  // since we can't write do while.
  // we loop over all iterations count. just want to make this code more semantically.
  @for $i from 1 through $_SUBDIVISION_MAX_ITERATIONS {
    // @debug 'binary subdivide count #{$i} times`';
    @if not $currentX or abs($currentX) > $_SUBDIVISION_PRECISION {
      $currentT: $aA + ($aB - $aA) / 2.0;
      $currentX: _calcBezier($currentT, $mX1, $mX2) - $aX;
      @if ($currentX > 0.0) {
        $aB: $currentT;
      } @else {
        $aA: $currentT;
      }

      // @debug 'current X is #{$currentX}';
      // @debug 'current T is #{$currentT}';
    }
  }

  @return $currentT;
}

@function _newton-raphson-iterate ($aX, $aGuessT, $mX1, $mX2) {
  @for $i from 1 through $_NEWTON_ITERATIONS {
    // @debug '-->newton raphsome iterate #{$i} times';

    $currentSlope: _getSlope($aGuessT, $mX1, $mX2);
    @if ($currentSlope == 0.0) {
      @return $aGuessT;
    }
    $currentX: _calcBezier($aGuessT, $mX1, $mX2) - $aX;
    $aGuessT: $aGuessT - $currentX / $currentSlope;

    // @debug 'current slope is #{$currentSlope}';
    // @debug 'current calculate X is #{$currentX}';
    // @debug 'guess T is #{$aGuessT}';
  }
  @return $aGuessT;
}

@function _getTForX ($mX1, $mX2, $aX) {

  // Precompute samples table
  //$sampleValues: float32ArraySupported ? new Float32Array(kSplineTableSize) : new Array(kSplineTableSize);
  $sampleValues: ();
  @for $i from 0 to $_kSplineTableSize {
    $sampleValues: append($sampleValues, _calcBezier($i * $_kSampleStepSize, $mX1, $mX2));
  }

  // @debug 'samplevalues is `#{$sampleValues}`';

  $intervalStart: 0.0;
  $currentSample: 2;
  $lastSample: $_kSplineTableSize - 1;

  //for (; currentSample !== lastSample && sampleValues[currentSample] <= aX; ++currentSample) {
  //  intervalStart += kSampleStepSize;
  //}
  @while $currentSample != $lastSample and nth($sampleValues, $currentSample) <= $aX {
    $currentSample: $currentSample + 1;
    $intervalStart: $intervalStart+ $_kSampleStepSize;
  }
  $currentSample: $currentSample - 1;

  // Interpolate to provide an initial guess for t
  $dist: ($aX - nth($sampleValues, $currentSample)) / (nth($sampleValues, $currentSample + 1) - nth($sampleValues, $currentSample));
  $guessForT: $intervalStart + $dist * $_kSampleStepSize;

  $initialSlope: _getSlope($guessForT, $mX1, $mX2);

  // @debug '$intervalStart is #{$intervalStart}';
  // @debug '$dist is #{$dist}';
  // @debug '$guessForT is #{$guessForT}';
  // @debug '$initialSlope is #{$initialSlope}';

  @if ($initialSlope >= $_NEWTON_MIN_SLOPE) {
    @return _newton-raphson-iterate($aX, $guessForT, $mX1, $mX2);
  } @else if ($initialSlope == 0.0) {
    @return $guessForT;
  } @else {
    @return _binary-subdivide($aX, $intervalStart, $intervalStart + $_kSampleStepSize, $mX1, $mX2);
  }
}

@function _bezier-easing($mX1, $mY1, $mX2, $mY2, $x) {
  @if not (0 <= $mX1 and $mX1 <= 1 and 0 <= $mX2 and $mX2 <= 1) {
    @error 'bezier x values must be in [0, 1] range';
  }

  @if ($mX1 == $mY1 and $mX2 == $mY2) {
    @return $x; // linear
  }
  // Because JavaScript number are imprecise, we should guarantee the extremes are right.
  @if ($x == 0) {
    @return 0;
  }
  @if ($x == 1) {
    @return 1;
  }
  // @debug 'get bezier easing value from x `#{$x}` with point (#{$mX1}, #{$mY1}) (#{$mX2}, #{$mY2})} is `#{_calcBezier(_getTForX($mX1, $mX2, $x), $mY1, $mY2)}`';
  @return _calcBezier(_getTForX($mX1, $mX2, $x), $mY1, $mY2);
}

@function color-easing ($x) {
   //@debug 'the x value will be calculated `#{$x}`';
  @return percentage(_bezier-easing(0.26, 0.09, 0.37, 0.18, $x));
}
